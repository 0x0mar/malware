#!/usr/bin/python

"""
Hacking Team 'core-packer' PoC detector
Copyright (C) 2015 - Jos Wetzels.
See the file 'LICENSE' for copying permission.

Proof-of-Concept detector script for PEs packed with Hacking Team's 'core-packer' (https://github.com/hackedteam/core-packer/)
See http://samvartaka.github.io/malware/2015/09/13/hackingteam-crypter/ for more details.
"""

import argparse
import pefile
from collections import defaultdict
from ngram import *
from profiles import *

class NgramProfiler:
	def get_ngrams(self, data, n):
		return list(NGram(N = n).ngrams(data))

	def get_ngram_absolute_frequencies(self, data, n):
		return NGram([data], N= n, pad_len=0)._grams

	def get_ngram_relative_frequencies(self, data, n):
		l = len(data)
		absolute = self.get_ngram_absolute_frequencies(data, n)
		relative = defaultdict(float)

		for gram in absolute:
			relative[gram] = (absolute[gram][data] / float(l))

		return relative

	def error(self, f, lookup_table):
		e = 0.0
		for gram in lookup_table:
			e += abs(lookup_table[gram] - f[gram])
		return e

class PackerAnalyzer(object):
	def __init__(self):
		return

	def xor_strings(self, xs, ys):
		return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))

	def get_blocks(self, data, block_size):
		return [data[i:i+block_size] for i in range(0, len(data), block_size)]

	def get_section_by_name(self, pe, name):
		for section in pe.sections:
			if(section.Name[:len(name)] == name):
				return section
		return None

	# Get identical blocks per section
	def get_identical_blocks_per_section(self, pe, use_sections):
		identical_blocks = {}
		for section in pe.sections:
			secname = section.Name[:section.Name.index("\x00")]

			# Is target core-packer section and under our consideration?
			if((hasattr(section, 'IMAGE_SCN_MEM_EXECUTE') or (secname == ".data")) and (secname in use_sections)):
				# Use list where each element is a list of offsets holding identical blocks
				iblocks = []

				# Get section data
				section_data = section.get_data()

				# Divide into TEA-sized blocks
				blocks = self.get_blocks(section_data, 8)

				# Dictionary mapping a block to all the offsets it occurs at
				block_dict = {}
				
				# Enumerate blocks
				for i in xrange(len(blocks)):
					block = blocks[i]
					offset = i*8
					if block in block_dict:
						block_dict[block].append(offset)
					else:
						block_dict[block] = [offset]

				# Remove all non-duplicate blocks
				for block in block_dict:
					if(len(block_dict[block]) > 1):
						iblocks.append(block_dict[block])

				identical_blocks[secname] = iblocks
		return identical_blocks

	# Checks whether ECB-mode constraint defined by profile holds over encrypted sections
	def check_iblock_profile(self, pe, profile):
		iblocks1 = self.get_identical_blocks_per_section(pe, profile['sections'])
		iblocks2 = profile['iblocks']
		for section in iblocks2:
			for ioffsets in iblocks2[section]:
				if not(ioffsets in iblocks1[section]):
					return False
		return True

	# Check whether a malicious ECB-mode constraint profile holds over PE
	def exe_check(self, pe, profiles):
		print "[*]Matching known ECB-mode profiles..."
		for profile in profiles:
			if(self.check_iblock_profile(pe, profiles[profile])):
				print "[!]File matches malicious profile of '%s'!" % profile
				return True

		print "[+]File matches no known malicious profiles"
		return False

	# Checks whether parallel ciphertext constraints hold on offset
	def check_offset(self, pe, offset, offset_list):
		# Need at least 2 known plaintexts
		assert(len(offset_list) > 1)

		# Use first known plaintext to derive keystream
		section = self.get_section_by_name(pe, offset_list[0]['section_name'])
		assert(section != None)

		# Has to be a core-packer section encryption candidate
		assert((hasattr(section, 'IMAGE_SCN_MEM_EXECUTE') or (section.Name[:5] == ".data")))

		section_data = section.get_data()
		assert(len(section_data) > offset)

		# Derive keystream from known plaintext and ciphertext
		known_plaintext = offset_list[0]['plaintext']
		keystream = self.xor_strings(known_plaintext, section_data[offset: offset+len(known_plaintext)])

		# Check whether keystream holds over other known plaintexts at identical offsets
		for i in xrange(1, len(offset_list)):
			section = self.get_section_by_name(pe, offset_list[i]['section_name'])
			assert(section != None)

			# Has to be a core-packer section encryption candidate
			assert((hasattr(section, 'IMAGE_SCN_MEM_EXECUTE') or (section.Name[:5] == ".data")))

			section_data = section.get_data()
			assert(len(section_data) > offset)

			known_plaintext = offset_list[i]['plaintext']
			candidate_plaintext = self.xor_strings(section_data[offset: offset+len(known_plaintext)], keystream)
			if(candidate_plaintext != known_plaintext):
				return False

		return True

	# Checks whether parallel ciphertext constraints hold over a known malicious profile of offsets
	def check_known_plaintext_profile(self, pe, profile):
		for offset in profile:
			if not(self.check_offset(pe, offset, profile[offset])):
				return False
		return True

	# Checks whether target DLL matches known malicious file packed with core-packer
	def dll_check_known_plaintexts(self, pe, profiles):
		print "[*]Matching known plaintext profiles..."
		for profile in profiles:
			if(self.check_known_plaintext_profile(pe, profiles[profile])):
				print "[!]File matches malicious profile of '%s'!" % profile
				return True

		print "[+]File matches no known malicious profiles"
		return False

	# Obtains statistical profile for target PE
	def get_statistical_profile(self, pe, use_sections, n):
		data_blob = ""

		# Use even number of sections (at least 2) to 'cancel out' keystreams
		assert((len(use_sections) >= 2) and (len(use_sections) % 2 == 0))

		for section in pe.sections:
			secname = section.Name[:section.Name.index("\x00")]

			# Is target core-packer section and under our consideration?
			if((hasattr(section, 'IMAGE_SCN_MEM_EXECUTE') or (secname == ".data")) and (secname in use_sections)):
				section_data = section.get_data()

				# Set data_blob to XOR between current content and section ciphertext
				if(data_blob == ""):
					data_blob = section_data
				else:
					data_blob = self.xor_strings(data_blob[:min(len(section_data), len(data_blob))], section_data[:min(len(section_data), len(data_blob))])

		# Get n-gram profile
		return NgramProfiler().get_ngram_relative_frequencies(data_blob, n)

	def dll_check_statistical_profiles(self, pe, profiles):
		print "[*]Matching statistical profiles..."
		for profile in stat_profiles:
			# Determine n-gram profile of parallel plaintexts in packed file
			p1 = self.get_statistical_profile(pe, stat_profiles[profile]['sections'], stat_profiles[profile]['n'])
			# Compare with n-gram profile of known malicious file
			p2 = [stat_profiles[profile]['profile']]
			# Check whether error is below error margin
			e = min([NgramProfiler().error(p1, x) for x in p2])
			if(e <= stat_profiles[profile]['error_margin']):
				print "[!]File matches malicious profile of '%s'!" % profile
				return True
				
		print "[+]File matches no known malicious profiles"
		return False

# Command-line argument parsing functionality
class ArgParser(argparse.ArgumentParser):
    def error(self, message):
        print "[-]Error: %s\n" % message
        self.print_help()
        exit()

# Command-line argument parser
def get_arg_parser():
	header = ""

	parser = ArgParser(description=header)	
	parser.add_argument('--file', dest='file', help='file to analyze', required=True)
	parser.add_argument('--stats', dest='stats', help='analyze using statistical profiles (instead of known plaintexts). DLLs only.', action='store_true')

	parser.add_argument('--get-ecb', dest='get_ecb', help='Get ECB mode identical blocks profile. Executables only. Specify sections to consider: eg. --get-ecb .text .data', nargs='+')
	parser.add_argument('--get-stats', dest='get_stats', help='Get statistical profile. DLLs only. Specify sections to consider: eg. --get-stats .text .data', nargs='+')
	parser.add_argument('--n', dest='n', help='N-Gram size for statistical profile', type=int)

	return parser

banner = "\t.Hacking Team 'core-packer' PoC detector.\n\t\t(c) 2015, Jos Wetzels\n"

def main():
	print banner

	parser = get_arg_parser()
	args = parser.parse_args()

	pe = pefile.PE(args.file)
	analyzer = PackerAnalyzer()

	if(args.get_stats):
		if not(pe.is_dll()):
			raise Exception("[-]Error: --get-stats applies to DLLs only...")
		if not((len(args.get_stats) % 2 == 0) and (len(args.get_stats) >= 2)):
			raise Exception("[-]Error: number of sections has to be a multiple of 2 and >= 2")
		if not(args.n):
			raise Exception("[-]Error: --n missing...")

		print analyzer.get_statistical_profile(pe, args.get_stats, args.n)
	elif(args.get_ecb):
		if not(pe.is_exe()):
			raise Exception("[-]Error: --get-ecb applies to executables only...")

		print analyzer.get_identical_blocks_per_section(pe, args.get_ecb)
	else:
		if(pe.is_exe()):
			analyzer.exe_check(pe, iblock_profiles)
		elif(pe.is_dll()):
			if(args.stats):
				analyzer.dll_check_statistical_profiles(pe, stat_profiles)
			else:
				analyzer.dll_check_known_plaintexts(pe, kp_profiles)
		else:
			raise Exception("[-]File is neither executable nor DLL...")

if __name__ == "__main__":
	main()			